        if (threadIdx.x < RADIX)
        {
            uint32_t reduction = s_warpHistograms[threadIdx.x];
            for (uint32_t i = threadIdx.x + RADIX; i < 4096; i += RADIX)
            {
                reduction += s_warpHistograms[i];
                s_warpHistograms[i] = reduction - s_warpHistograms[i];
            }

            //begin the exclusive prefix sum across the reductions
            s_warpHistograms[threadIdx.x] = InclusiveWarpScanCircularShift(reduction);
        }
        __syncthreads();

        if (threadIdx.x < (RADIX >> LANE_LOG))
            s_warpHistograms[threadIdx.x << LANE_LOG] = ActiveExclusiveWarpScan(s_warpHistograms[threadIdx.x << LANE_LOG]);
        __syncthreads();

        if (threadIdx.x < RADIX && getLaneId())
            s_warpHistograms[threadIdx.x] += __shfl_sync(0xfffffffe, s_warpHistograms[threadIdx.x - 1], 1);
        __syncthreads();

        //update offsets
        if (WARP_INDEX)
        {
#pragma unroll 
            for (uint32_t i = 0; i < 15; ++i)
            {
                const uint32_t t2 = keys[i] >> radixShift & RADIX_MASK;
                offsets[i] += s_warpHist[t2] + s_warpHistograms[t2];
            }
        }
        else
        {
#pragma unroll
            for (uint32_t i = 0; i < 15; ++i)
                offsets[i] += s_warpHistograms[keys[i] >> radixShift & RADIX_MASK];
        }

        //load in threadblock reductions
        if (threadIdx.x < RADIX)
        {
            //记录某个部分中桶的起始位置
            s_localHistogram[threadIdx.x] = globalHist[threadIdx.x + (radixShift << 5)] +
                passHist[threadIdx.x * gridDim.x + blockIdx.x] - s_warpHistograms[threadIdx.x];
        }
        __syncthreads();

        //scatter keys into shared memory
#pragma unroll
        for (uint32_t i = 0; i < 15; ++i)
            s_warpHistograms[offsets[i]] = keys[i];
        __syncthreads();

        //scatter runs of keys into device memory
        if (blockIdx.x < gridDim.x - 1)
        {
#pragma unroll 15
            for (uint32_t i = threadIdx.x; i < 7680; i += blockDim.x)
                result[s_localHistogram[s_warpHistograms[i] >> radixShift & RADIX_MASK] + i] = s_warpHistograms[i];
        }

        if (blockIdx.x == gridDim.x - 1)
        {
            const uint32_t finalPartSize = sort_size - blockIdx.x * 7680;
            for (uint32_t i = threadIdx.x; i < finalPartSize; i += blockDim.x)
                result[s_localHistogram[s_warpHistograms[i] >> radixShift & RADIX_MASK] + i] = s_warpHistograms[i];
        }